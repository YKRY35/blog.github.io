<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>RetransformClass对运行时类方法的影响，及底层机理 &mdash; Zhou</title><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/collection.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/globals/common.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/posts/index.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/octicons/octicons/octicons.css"><link href="https://ykry35.github.io/blog.github.io/assets/vendor/viewerjs/viewer.min.css" rel="stylesheet"><link href="https://ykry35.github.io/blog.github.io/assets/css/globals/viewerjs.cust.css" rel="stylesheet"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/code_theme/github.css"><link rel="canonical" href="https://ykry35.github.io/blog.github.io/2021/08/31/retransform_class_mechanism/"><link rel="alternate" type="application/atom+xml" title="Zhou" href="https://ykry35.github.io/blog.github.io/feed.xml"><link rel="shortcut icon" href="https://ykry35.github.io/blog.github.io/favicon.ico"><meta property="og:title" content="RetransformClass对运行时类方法的影响，及底层机理"><meta name="keywords" content="JVM, hotspot, Java"><meta name="og:keywords" content="JVM, hotspot, Java"><meta name="description" content="RetransformClass 可以在运行时修改类的方法，如果一个方法正在运行，比如while(true)，这个时候，我修改这个方法，在里面加一些指令，那么对原来运行中的方法会产生什么影响呢？以及他背后的原理是什么呢？"><meta name="og:description" content="RetransformClass 可以在运行时修改类的方法，如果一个方法正在运行，比如while(true)，这个时候，我修改这个方法，在里面加一些指令，那么对原来运行中的方法会产生什么影响呢？以及他背后的原理是什么呢？"><meta property="og:url" content="https://ykry35.github.io/blog.github.io/2021/08/31/retransform_class_mechanism/"><meta property="og:site_name" content="Zhou"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-08-31"> <script src="https://ykry35.github.io/blog.github.io/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/js/jquery-ui.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/js/main.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/vendor/viewerjs/viewer.min.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://ykry35.github.io/blog.github.io/" title="Zhou"><span class="octicon octicon-mark-github"></span> Zhou</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://ykry35.github.io/blog.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://ykry35.github.io/blog.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://ykry35.github.io/blog.github.io/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://ykry35.github.io/blog.github.io/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://ykry35.github.io/blog.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="RetransformClas"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">RetransformClass对运行时类方法的影响，及底层机理</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/08/31 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://ykry35.github.io/blog.github.io/categories/#JVM" title="JVM">JVM</a> </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>RetransformClass 可以在运行时修改类的方法，如果一个方法正在运行，比如while(true)，这个时候，我修改这个方法，在里面加一些指令，那么对原来运行中的方法会产生什么影响呢？以及他背后的原理是什么呢？</p><h1 id="先下结论">先下结论</h1><p>原来正在执行的方法，即栈帧中的方法，还会按照原来的方法执行，不会受到影响。新的方法调用会执行重定义后的方法。</p><h2 id="jdk-18-文档中有说明">Jdk 1.8 文档中，有说明</h2><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * If a retransformed method has active stack frames, those active frames continue to
 * run the bytecodes of the original method.
 * The retransformed method will be used on new invokes.

 * Instances of the retransformed class are not affected.
 
 * The retransformation may change method bodies, the constant pool and attributes.
 * The retransformation must not add, remove or rename fields or methods, change the
 * signatures of methods, or change inheritance.  
 */</span>
<span class="kt">void</span> <span class="nf">retransformClasses</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;...</span> <span class="n">classes</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">UnmodifiableClassException</span><span class="o">;</span>
</code></pre></div></div><h2 id="本人也做过实验">本人也做过实验</h2><p>写了一个类K，主线程调用的loop，会一直在栈帧中（不退出while），但子线程会不断调用loop。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">K</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">(</span><span class="kt">int</span> <span class="n">bbb</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bbb</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">bbb</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">loop</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1500</span><span class="o">);</span>
        <span class="n">loop</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>打印： 1 11 \n 0 11 \n 1 11 \n 0 11 ……</p><p>之后，用ASM将loop的方法内容给修改， x+1 修改成 x+5.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitInsn</span><span class="o">(</span><span class="kt">int</span> <span class="n">opcode</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">loop</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">==</span> <span class="nc">Opcodes</span><span class="o">.</span><span class="na">ICONST_1</span><span class="o">)</span> <span class="o">{</span><span class="c1">// ICONST_1 指令修改成 ICONST_5</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">visitInsn</span><span class="o">(</span><span class="nc">Opcodes</span><span class="o">.</span><span class="na">ICONST_5</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">visitInsn</span><span class="o">(</span><span class="n">opcode</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>打印： 1 11 \n 0 15 \n 1 11 \n 0 15 ……</p><p>说明主线程还是打印11，按照老的方法来执行，而子线程重新调用的已经变成更新后的方法了。</p><h1 id="原因的概述">原因的概述</h1><p>hotspot有两种执行模式： 解释执行，即时编译。 之后都以解释执行为例，解释这个问题。</p><p>（hotspot，“热点”名称由来，即为对热点代码即时编译)</p><p>（java -version结尾mixed mode，也即混合模式，解释执行+即时编译混合）</p><ol><li><p>重定义字节码，不会改变InstanceKlass实例本身，只是他持有的Method，Constantpool等引用全被替换成了新的。</p></li><li><p>解释执行时的 模板解释器，是如何跳转到下一条指令的。分析可知， cpu中的 r13 寄存器，保存着当前执行字节码的地址(ConstMethod中的)。遇到跳转指令和非跳转指令(不是调用方法那种），r13 寄存器地址只能在当前这个ConstMethod的字节码区域滑动，不会受新生成的方法影响。</p></li><li><p>方法中invoke指令，调用目标函数信息，是静态常量池的符号引用（字节码常量池的下标）。方法链接（link）即是将符号引用转成直接应用，缓存目标方法的内存地址在运行时常量池中，下次直接用即可，不需要再解析静态常量池。那既然缓存了，为什么新的调用还是能指向新的Method呢？</p></li><li><p>直接引用的缓存，保存在运行常量池中（ConstantPool）的ConstantPoolCache里。这个cache包括了多个ConstantPoolCacheEntry，地址信息都在这个entry里。重定义字节码，会扫描JVM内所有的类的ConstantPoolCache，把旧的Method地址缓存删除。</p></li></ol><p>综上，老的方法执行不受影响，且新的调用能够正确指向新的方法。（JIT编译执行也同理）</p><h1 id="java程序是如何执行的">Java程序是如何执行的</h1><p>传送门： <a href="https://ykry35.github.io/blog.github.io/2021/09/01/how_does_the_java_program_run/">Java程序是如何执行的</a></p><h1 id="redefineclass">RedefineClass</h1><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">VM_RedefineClasses</span><span class="o">::</span><span class="n">redefine_single_class</span><span class="p">(</span><span class="n">jclass</span> <span class="n">the_jclass</span><span class="p">,</span>
       <span class="n">Klass</span><span class="o">*</span> <span class="n">scratch_class_oop</span><span class="p">,</span> <span class="n">TRAPS</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// 省去一部分代码。</span>
  <span class="c1">// 新解析的Klass中的东西，替换掉老的Klass。 能替换的都替换了</span>

  <span class="n">the_class</span><span class="o">-&gt;</span><span class="n">set_methods</span><span class="p">(</span><span class="n">_new_methods</span><span class="p">);</span>
  <span class="n">scratch_class</span><span class="o">-&gt;</span><span class="n">set_methods</span><span class="p">(</span><span class="n">_old_methods</span><span class="p">);</span>     <span class="c1">// To prevent potential GCing of the old methods,</span>
                                          <span class="c1">// and to be able to undo operation easily.</span>

  <span class="n">ConstantPool</span><span class="o">*</span> <span class="n">old_constants</span> <span class="o">=</span> <span class="n">the_class</span><span class="o">-&gt;</span><span class="n">constants</span><span class="p">();</span>
  <span class="n">the_class</span><span class="o">-&gt;</span><span class="n">set_constants</span><span class="p">(</span><span class="n">scratch_class</span><span class="o">-&gt;</span><span class="n">constants</span><span class="p">());</span>
  <span class="n">scratch_class</span><span class="o">-&gt;</span><span class="n">set_constants</span><span class="p">(</span><span class="n">old_constants</span><span class="p">);</span>  <span class="c1">// See the previous comment.</span>
  
  <span class="c1">// ......</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">the_class</span><span class="o">-&gt;</span><span class="n">oop_map_cache</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Flush references to any obsolete methods from the oop map cache</span>
    <span class="c1">// so that obsolete methods are not pinned.</span>
    <span class="n">the_class</span><span class="o">-&gt;</span><span class="n">oop_map_cache</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flush_obsolete_entries</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="c1">// end redefine_single_class()</span>

</code></pre></div></div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://ykry35.github.io/blog.github.io" target="_blank">Chaoxin Zhou</a></li><li>本文链接：<a href="https://ykry35.github.io/blog.github.io/2021/08/31/retransform_class_mechanism/" target="_blank">https://ykry35.github.io/blog.github.io/2021/08/31/retransform_class_mechanism/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/08/31/retransform_class_mechanism/', clientID: 'a3a0fbaad3e91f2e2342', clientSecret: 'f82d523505992a3aab199b818ecff081b65f1a60', repo: 'blog.github.io', owner: 'ykry35', admin: ['ykry35'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://ykry35.github.io/blog.github.io/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://ykry35.github.io/blog.github.io/assets/search_data.json?v=1673186855', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://ykry35.github.io/blog.github.io/assets/js/jquery.toc.js"></script></div></div><script type="text/javascript"> $(document).ready(function(){ const jekyllConfigId = '#jekyllconfig'; const imageGroupClass = '.images_group'; $(jekyllConfigId).hide(); var configStr = $(jekyllConfigId).text().trim(); const jekyllConfig = JSON.parse(configStr); console.log("jekyllConfig", jekyllConfig); $(imageGroupClass + ' li').css('width', jekyllConfig['viewerjs']['img_width']); $(imageGroupClass).each(function(index, element) { new Viewer(element); }); }); </script></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Chaoxin Zhou">Chaoxin Zhou</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/YKRY35/" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://ykry35.github.io/blog.github.io/" title="首页" target="">首页</a></li><li> <a href="https://ykry35.github.io/blog.github.io/categories/" title="分类" target="">分类</a></li><li> <a href="https://ykry35.github.io/blog.github.io/wiki/" title="维基" target="">维基</a></li><li> <a href="https://ykry35.github.io/blog.github.io/links/" title="链接" target="">链接</a></li><li> <a href="https://ykry35.github.io/blog.github.io/about/" title="关于" target="">关于</a></li><li><a href="https://ykry35.github.io/blog.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://ykry35.github.io/blog.github.io/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
