<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java程序在虚拟机是怎么执行的？（汇编层面分析） &mdash; Zhou</title><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/collection.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/globals/common.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/posts/index.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/octicons/octicons/octicons.css"><link href="https://ykry35.github.io/blog.github.io/assets/vendor/viewerjs/viewer.min.css" rel="stylesheet"><link href="https://ykry35.github.io/blog.github.io/assets/css/globals/viewerjs.cust.css" rel="stylesheet"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/code_theme/github.css"><link rel="canonical" href="https://ykry35.github.io/blog.github.io/2021/09/01/how_does_the_java_program_run/"><link rel="alternate" type="application/atom+xml" title="Zhou" href="https://ykry35.github.io/blog.github.io/feed.xml"><link rel="shortcut icon" href="https://ykry35.github.io/blog.github.io/favicon.ico"><meta property="og:title" content="Java程序在虚拟机是怎么执行的？（汇编层面分析）"><meta name="keywords" content="JVM, hotspot, Java"><meta name="og:keywords" content="JVM, hotspot, Java"><meta name="description" content="正在研究openjdk8源码，着重研究字节码指令在汇编层面的解释执行，感受到了其间许多超级精妙的设计。"><meta name="og:description" content="正在研究openjdk8源码，着重研究字节码指令在汇编层面的解释执行，感受到了其间许多超级精妙的设计。"><meta property="og:url" content="https://ykry35.github.io/blog.github.io/2021/09/01/how_does_the_java_program_run/"><meta property="og:site_name" content="Zhou"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-09-01"> <script src="https://ykry35.github.io/blog.github.io/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/js/jquery-ui.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/js/main.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/vendor/viewerjs/viewer.min.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://ykry35.github.io/blog.github.io/" title="Zhou"><span class="octicon octicon-mark-github"></span> Zhou</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://ykry35.github.io/blog.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://ykry35.github.io/blog.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://ykry35.github.io/blog.github.io/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://ykry35.github.io/blog.github.io/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://ykry35.github.io/blog.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java程序在虚拟机是怎么执行"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java程序在虚拟机是怎么执行的？（汇编层面分析）</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/09/01 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://ykry35.github.io/blog.github.io/categories/#JVM" title="JVM">JVM</a> </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>正在研究openjdk8源码，着重研究字节码指令在汇编层面的解释执行，感受到了其间许多超级精妙的设计。</p><h1 id="行文结构">行文结构</h1><p>见 <a href="#总结">总结</a></p><h1 id="java程序是如何执行的字节码层面">Java程序是如何执行的(字节码层面)</h1><p>我们在做字节码相关的开发时，只需要大致了解，每个字节码指令在JVM中是如何解释执行的，以及虚拟机对字节码的校验即可，不需要过底层的原理。</p><p>最常见的，需要关注这几个： 本地变量表(local variables), 操作数栈(operand stack)，静态常量池(constant pool)。</p><p>就像逆波兰表达式，每个符号操作其实都是对栈顶元素的操作。字节码指令也一样，每个指令会影响当前方法栈帧中的本地变量表和操作数栈，或者是进行指令跳转（类似PC，实际更改r13寄存器地址值）。</p><p>以一个Java程序为例。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">y</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">){</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>编译后的.class长这样：</p><pre><code class="language-ASM">int y(int);
descriptor: (I)I
flags:
Code:
  stack=2, locals=3, args_size=2
     0: bipush        10
     2: istore_2
     3: iload_1
     4: iload_2
     5: iadd
     6: iconst_1
     7: iadd
     8: ireturn
  LineNumberTable:
    line 8: 0
    line 9: 3
  LocalVariableTable:
    Start  Length  Slot  Name   Signature
        0       9     0  this   LO;
        0       9     1     a   I
        3       6     2     w   I
</code></pre><p>这个是javap -v -l -p A.class生成的，将下标引用转为了符号引用。</p><p>可以看到，本地变量表（以slot为单位，double，long占两个slot，其余均占1个slot）： slot0 是方法隐藏入参 this，slot1 是方法入参int a，slot2是int w.</p><p>本地变量表locals=3，3个槽（注意，因为变量存在作用域，所以这个槽是可以复用的，所以Start和Length的意义正在于此）</p><p>操作数栈深度为stack=2，最大只能有2个operand在栈中。</p><p>之后，每个字节码指令被虚拟机顺序解释执行，每个指令解释执行完，操作数栈的情况，我写在下面的注释中了。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              # stack: []   左边为栈底，右边为栈顶
0: bipush 10  # 将10压入栈中。 stack: [ 10 ]
2: istore_2   # 将栈顶元素弹出，放入locals 2中（此时本地变量2，即w被赋值为10）。  stack: [ ] 
3: iload_1    # 本地变量 1压栈（即将a的值压栈，a是调用者赋值的[实际细节是，栈帧重叠，较复杂]。 stack: [ a的值 ]
4: iload_2    # 本地变量 2压栈 .   stack: [ a的值 ， w的值 ]
5: iadd       # 栈顶两个元素弹出，相加，结果压栈。  stack： [ a+w的值 ]
6: iconst_1   # 将1压栈。  stack: [a+w的值 ， 1 ]
7: iadd       # 栈顶两个元素弹出，相加，结果压栈。  stack： [ a+w+1的值 ]
8: ireturn    # 栈顶元素弹出，作为方法return值。 stack: [ ]
</code></pre></div></div><p>每个指令的操作描述，wiki传送门： <a href="https://ykry35.github.io/blog.github.io/wiki/bytecode_instruction/">bytecode instruction</a></p><p>至此，Java编译后的.class，在虚拟机中的解释方式，大致是清楚了，剩下别的指令，模式差不多。</p><p>（笔者目前觉得ASM的使用，难度主要在于静态指令分析，根据一个个指令，分析程序流。还有较长的路要走）</p><h1 id="字节码在虚拟机中的执行汇编层面">字节码在虚拟机中的执行（汇编层面）</h1><h2 id="java程序本质">Java程序本质</h2><h3 id="猜想">猜想</h3><p>通常联系前面的大致原理，在猜测虚拟机的实现时，可能想当然的认为，本地变量表和操作数栈在hotspot中就是C++表示的定长数组。解释指令时，对数组内容进行操作就行了。</p><p>最终对指令的解析可能是如下的结构:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">bytecode</span><span class="p">){</span>
    <span class="k">case</span> <span class="n">ICONST_0</span><span class="p">:</span>
      <span class="n">stack</span><span class="p">[</span><span class="n">stkLen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ILOAD_0</span><span class="p">:</span>
      <span class="n">stack</span><span class="p">[</span><span class="n">stkLen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">locals</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="k">break</span><span class="p">;</span>
     <span class="c1">// ......</span>
  <span class="p">}</span>
  <span class="n">bytecode</span> <span class="o">=</span> <span class="n">fetch_next_bytecode</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="实际">实际</h3><p>但openjdk8为了性能，解释字节码执行的代码是硬编码机器指令在内存的（根据不同cpu，操作系统定制化）。</p><p>openjdk8执行方式有两种：解释执行，即时编译。对热点代码即时编译，hotspot名称也由此得来。java -version最后的mixed mode混合也是指的两种模式的混合。</p><p>下面的介绍都以解释执行为例。</p><h4 id="何为例程">何为例程</h4><p>这些硬编码在内存的指令，就像函数一样，只是省去了C++编译这一步，他们是通用的，比如特定字节码指令的处理例程，java方法入口开辟栈帧例程等等。</p><p>hotspot启动时，会生成例程时，他会为每个例程开辟一个可读可写可执行的内存区域（mac不支持，所以mac的jdk似乎是CppInterpreter，非TemplateInterpreter），在开辟的内存中硬编码了机器指令，然后将这块内存起始地址保存，作为例程入口。</p><p>（这也是为什么，一到了，指令执行，C++调试器就调试不了了。因为那些程序是运行时硬编码到内存的，没经过C++编译器。）</p><p>这么做的目的是，直接编译C++会产生一些无用机器指令，而硬编码可以减少这些不必要指令的生成，解释执行的性能会提高。（即时编译JIT则会分析整个方法字节码，进一步精简机器指令）。</p><h4 id="java方法是什么">Java方法是什么？</h4><p>从上文可以看出，Java方法的核心，就是经过前端编译器javac编译后的字节码。Java方法的执行，其实就是由C++硬编码进内存的这些汇编例程的执行。</p><p>Java方法的本质，我的理解：</p><ol><li><p>可执行bin/java的启动，就是C++的运行，入口是int main()。</p></li><li><p>类加载，加载的字节码文件被解析为JVM内部数据结构。字节码的所有指令及操作数，排列在内存。一些额外信息也在内存。</p></li><li><p>Java方法被调用(invoke指令或者C++进入Java)时，用于开辟栈帧的method_entry例程被触发，method_entry根据这个Java方法在JVM的内部表示 Method数据结构，来开辟这个Java方法的调用栈空间(包含本地变量表和操作数栈，返回地址等信息）。并且程序计数器(r13寄存器)指向第一个字节码指令的地址。</p></li><li><p>method_entry例程开辟栈帧空间完（这个栈帧是寄生在宿主栈的，和汇编调用共用相同的栈），r13寄存器赋值完，就跳(jmp)到r13寄存器指向的字节码指令的处理例程，即字节码指令解释执行例程。</p></li><li><p>每个字节码指令例程执行到最后，会更新r13寄存器（选择顺序执行或者如jmp指令跳转），指向下个要执行指令的地址，然后jmp到下一个指令对应的例程。</p></li><li><p>当遇到invoke指令，即调用java方法或本地方法，先把r13寄存器保存在当前栈中（用于调用返回后恢复现场），然后callq 触发相应的method_entry例程，开辟栈帧执行目标方法（同第2条）。</p></li><li><p>当遇到return指令(ireturn, return等)，把返回值（即操作数栈顶元素）保存到相应位置，然后拿到栈帧中保存的的return_address，删除栈帧，返回上一次callq的地址。</p></li><li><p>返回调用处，比如invoke指令的例程中，从栈帧中拿到r13寄存器指向的字节码地址，恢复现场，继续当前java字节码的执行。</p></li></ol><p>上面，解释了Java方法以及Java方法调用在底层的本质。那么C++世界是如何进入Java世界的呢，Java世界如何回到C++世界的呢？</p><p>hostspot启动，虚拟机创建完，会找到main方法对应的方法区的C++ Method对象，然后通过CallStub例程，做好栈的准备，紧接着触发这个Java Method对应的methd_entry，进入java的世界。</p><p>method_entry结束，回到CallStub例程，处理返回result，又回到了C++的世界。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">JNICALL</span>
<span class="nf">JavaMain</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">_args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mainClass</span> <span class="o">=</span> <span class="n">LoadMainClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">what</span><span class="p">);</span> 
    <span class="n">CHECK_EXCEPTION_NULL_LEAVE</span><span class="p">(</span><span class="n">mainClass</span><span class="p">);</span>

    <span class="n">mainID</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetStaticMethodID</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">mainClass</span><span class="p">,</span> <span class="s">"main"</span><span class="p">,</span>
                                       <span class="s">"([Ljava/lang/String;)V"</span><span class="p">);</span><span class="c1">// 找到 public static void main(String[] args) 方法</span>

    <span class="n">mainArgs</span> <span class="o">=</span> <span class="n">CreateApplicationArgs</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span> <span class="c1">// Java启动参数，用于传递给main方法</span>

    <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">CallStaticVoidMethod</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">mainClass</span><span class="p">,</span> <span class="n">mainID</span><span class="p">,</span> <span class="n">mainArgs</span><span class="p">);</span> <span class="c1">// 执行</span>
<span class="p">}</span>
</code></pre></div></div><p>CallStaticVoidMethod最后会进入到call_helper. call_helper节选：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// do call</span>
  <span class="p">{</span> <span class="n">JavaCallWrapper</span> <span class="n">link</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">CHECK</span><span class="p">);</span>
    <span class="p">{</span> <span class="n">HandleMark</span> <span class="n">hm</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>  <span class="c1">// HandleMark used by HandleMarkCleaner</span>

      <span class="n">StubRoutines</span><span class="o">::</span><span class="n">call_stub</span><span class="p">()(</span> <span class="c1">//拿到call_stub例程地址，并执行stub例程</span>
        <span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="o">&amp;</span><span class="n">link</span><span class="p">,</span>
        <span class="c1">// (intptr_t*)&amp;(result-&gt;_value), // see NOTE above (compiler problem)</span>
        <span class="n">result_val_address</span><span class="p">,</span>          <span class="c1">// see NOTE above (compiler problem)</span>
        <span class="n">result_type</span><span class="p">,</span>
        <span class="n">method</span><span class="p">(),</span>
        <span class="n">entry_point</span><span class="p">,</span>
        <span class="n">args</span><span class="o">-&gt;</span><span class="n">parameters</span><span class="p">(),</span>
        <span class="n">args</span><span class="o">-&gt;</span><span class="n">size_of_parameters</span><span class="p">(),</span>
        <span class="n">CHECK</span>
      <span class="p">);</span>

      <span class="n">result</span> <span class="o">=</span> <span class="n">link</span><span class="p">.</span><span class="n">result</span><span class="p">();</span>  <span class="c1">// circumvent MS C++ 5.0 compiler bug (result is clobbered across call)</span>
      <span class="c1">// Preserve oop return value across possible gc points</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">oop_result_flag</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">set_vm_result</span><span class="p">((</span><span class="n">oop</span><span class="p">)</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">get_jobject</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="c1">// Exit JavaCallWrapper (can block - potential return oop must be preserved)</span>
</code></pre></div></div><p>call_stub()返回了CallStub例程的地址，CallStub是在hotspot启动时创建的例程</p><p>参数 entry_point 就是这个method的method_entry例程的地址。</p><p>比如，运行main方法，method对应的就是这个Java的main方法在虚拟机中的表示。</p><p>CallStub例程的一部分功能，会把Java方法参数放到栈顶，然后callq目标方法的method_entry。（后面会介绍Java方法的参数传递机制，CallStub的一部分作用就是兼容method_entry，为其准备好参数，因为Java方法1调Java方法2，方法2会直接借助方法1的操作数栈传参，CallStub则是C++进入Java，模仿方法1的行为，将参数准备在栈顶。下文栈帧重叠会详细介绍）</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">address</span> <span class="nf">generate_call_stub</span><span class="p">(</span><span class="n">address</span><span class="o">&amp;</span> <span class="n">return_address</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 省去了很多，主要几件事：</span>
    <span class="c1">//  1. 调用函数的规范，保存一些寄存器的值，结束时恢复现场 </span>
    <span class="c1">//  2. 把目标java方法，即Method数据结构相关值，存入寄存器</span>
    <span class="c1">//  3. 开辟栈空间，java参数压栈（java调用参数可以直接通过栈传递，例程做相应支持即可，不需要遵守汇编调用的规范）</span>

    <span class="c1">// call Java function</span>
    <span class="n">__</span> <span class="n">BIND</span><span class="p">(</span><span class="n">parameters_done</span><span class="p">);</span>
    <span class="n">__</span> <span class="n">movptr</span><span class="p">(</span><span class="n">rbx</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>             <span class="c1">// get Method*</span>
    <span class="n">__</span> <span class="n">movptr</span><span class="p">(</span><span class="n">c_rarg1</span><span class="p">,</span> <span class="n">entry_point</span><span class="p">);</span>    <span class="c1">// get entry_point</span>
    <span class="n">__</span> <span class="n">mov</span><span class="p">(</span><span class="n">r13</span><span class="p">,</span> <span class="n">rsp</span><span class="p">);</span>                   <span class="c1">// set sender sp</span>
    <span class="n">BLOCK_COMMENT</span><span class="p">(</span><span class="s">"call Java function"</span><span class="p">);</span>
    <span class="n">__</span> <span class="n">call</span><span class="p">(</span><span class="n">c_rarg1</span><span class="p">);</span> <span class="c1">// c_rarg1寄存器的值 就是这个方法的method_entry例程地址</span>

    <span class="c1">// 收尾，还原寄存器相关的。还有别的Java返回类型处理。（还要细看。。）</span>
  <span class="p">}</span>
</code></pre></div></div><p>__ call(c_rarg1); 是生成汇编指令的， 实际执行时，程序从这里 callq 到 Java方法对应的 method_entry例程，进入java的世界。(__是define的一个函数)</p><h2 id="重要的几个例程">重要的几个例程</h2><h3 id="method_entryjava方法入口">method_entry(Java方法入口)</h3><p>调用新的Java方法，首先会调用到对应Java方法的method_entry例程，开辟新的栈帧，保存相关数据，然后跳转到方法第一个字节码指令的例程。</p><p>看结构，AbstractInterpreter是字节码解释器的基类。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AbstractInterpreter</span><span class="o">:</span> <span class="n">AllStatic</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">enum</span> <span class="n">MethodKind</span> <span class="p">{</span>
    <span class="n">zerolocals</span><span class="p">,</span>                                                 <span class="c1">// method needs locals initialization</span>
    <span class="n">zerolocals_synchronized</span><span class="p">,</span>                                    <span class="c1">// method needs locals initialization &amp; is synchronized</span>
    <span class="n">native</span><span class="p">,</span>                                                     <span class="c1">// native method</span>
    <span class="c1">// ..... 省去了一些</span>
    <span class="n">number_of_method_entries</span><span class="p">,</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="p">};</span>
  <span class="c1">// 下标即是MethodKind，对应的值是每种MethodKind的例程入口地址</span>
  <span class="k">static</span> <span class="n">address</span>    <span class="n">_entry_table</span><span class="p">[</span><span class="n">number_of_method_entries</span><span class="p">];</span>     <span class="c1">// entry points for a given method</span>
<span class="p">}</span>
</code></pre></div></div><p>_entry_table存储了每种方法类型的method_entry例程的入口地址。</p><p>什么叫java方法类型呢？每一个java方法在C++中是一个Method对象，方法类型被分为了几种：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zerolocals
zerolocals_synchronized
native
native_synchronized
empty
.....
.....
</code></pre></div></div><p>据说哦，常见的就前面4种（这里笔者就稍微研究了第一种），普通java方法，同步java方法，本地方法，同步本地方法。</p><p>每一种Method类型，都对应了一段汇编例程。每个例程，开辟的栈帧是不同的，内容结构上有差异。</p><p>例如，zerolocals的method_entry例程生成器（节选）：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">address</span> <span class="n">InterpreterGenerator</span><span class="o">::</span><span class="n">generate_normal_entry</span><span class="p">(</span><span class="kt">bool</span> <span class="n">synchronized</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 省去了一部分 ConstMethod 相关变量的寻址</span>

  <span class="n">__</span> <span class="n">load_unsigned_short</span><span class="p">(</span><span class="n">rcx</span><span class="p">,</span> <span class="n">size_of_parameters</span><span class="p">);</span> <span class="c1">// rcx寄存器装入java方法入参个数</span>

  <span class="n">__</span> <span class="n">load_unsigned_short</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span> <span class="n">size_of_locals</span><span class="p">);</span> <span class="c1">// rdx寄存器装入java方法本地变量表大小</span>
  <span class="n">__</span> <span class="n">subl</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span> <span class="n">rcx</span><span class="p">);</span> <span class="c1">// 相减，则是剩余本地变量表大小，当前例程需要开辟的剩余变量表。即栈帧重叠的支持。</span>

  <span class="n">generate_stack_overflow_check</span><span class="p">();</span><span class="c1">// 生成栈溢出检测的汇编指令</span>

  <span class="n">__</span> <span class="n">pop</span><span class="p">(</span><span class="n">rax</span><span class="p">);</span><span class="c1">// 将callq指令留下的return_address弹出，装入到rax寄存器。</span>

  <span class="n">__</span> <span class="n">lea</span><span class="p">(</span><span class="n">r14</span><span class="p">,</span> <span class="n">Address</span><span class="p">(</span><span class="n">rsp</span><span class="p">,</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">Address</span><span class="o">::</span><span class="n">times_8</span><span class="p">,</span> <span class="o">-</span><span class="n">wordSize</span><span class="p">));</span> <span class="c1">// 计算本地变量表起始的基址。r14寄存器则为实际的栈帧开始（高地址）。</span>

  <span class="p">{</span>
    <span class="c1">// 这里是循环 rdx次， 往里面塞0，扩充出本地变量标实际大小。</span>
  <span class="p">}</span>

  <span class="n">generate_fixed_frame</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// 生成栈帧剩余部分，一些重要参数的保存（有些为何重要，笔者还未研究清除）</span>

  <span class="n">__</span> <span class="n">dispatch_next</span><span class="p">(</span><span class="n">vtos</span><span class="p">);</span> <span class="c1">// 这是一个关键的函数，涉及字节码指令的执行，后面介绍。在这里，将开始callq第一个字节码指令的例程</span>

  <span class="k">return</span> <span class="n">entry_point</span><span class="p">;</span><span class="c1">// 把例程地址保存，之后Method的_from_interpreted_entry则指向这个地址，表示java方法的例程入口。</span>
<span class="p">}</span>
</code></pre></div></div><p>从上面可以看出，normal_entry这个方法例程，会弹出callq指令的return_address，然后往里面塞入 locals - parameters 个元素。</p><p>可能会奇怪，本地变量表的大小明明是 locals个，为什么只开辟 locals - parameters个 slot呢。这是正是其设计巧妙之处，上一个栈帧的最后是操作数栈，最后parameters个元素为作为当前栈帧本地变量表的一部分，栈帧重叠！</p><p>这样设计，连传参都省去了，复用了一部分内存。后文画图介绍。</p><h4 id="方法栈帧">方法栈帧</h4><p>method_entry例程会在宿主栈，即汇编的调用栈上，开辟一块区域，作为Java的栈帧。<strong>zerolocals</strong> 为例，本地变量表在栈帧的底部（地址高位），操作数栈在栈帧的顶部（地址低位）。如下面左边的图：</p><p><img src="https://ykry35.github.io/blog.github.io/assets/images/jvm/stack_frame_simple.png" alt="" /></p><p>注意，这个是汇编调用的栈，Java的方法栈由对应的entry例程开辟，寄生在宿主栈中。这个栈是倒着的，新的方法从下面往上压栈。</p><p>左图中，反映了每个java方法对应的method_entry例程 开辟的栈空间，上面是方法A，调用了方法B，所以方法B的栈帧在下面。</p><p>左图，是实际情况下的栈帧划分，但逻辑上，栈帧之间是有重叠的！</p><p>如右图，方法A在执行invokevirtual指令之前，必然存在指令把调用者对象压栈，把方法B的两个参数（假设）1和2压栈，这时callq到方法B的method_entry时，方法B的method_entry例程，直接将方法A的倒数3个slot当成自己的本地变量表的一部分，并开辟出剩余部分（入参以外的大小），构成整个本地变量表。所以方法B实际可用栈帧涵盖了方法A的一部分！！！<strong>栈帧重叠</strong>！！！ （有个细节，callq后A栈帧和B栈帧中间会有个return_address，用来表示B执行完的返回地址，B的entry将这个地址弹出，保存在别的位置了，保证整个本地变量表的连续）</p><p>C++函数调用参数传递，需要遵守规范，借助栈或者寄存器；但Java直接通过这种方式，来传递参数，维护栈的同时，把变量都准备好了。</p><p>理解了这个，瞬间也对值传递，引用传递的底层完全理解了。传递数值时，被调方法将其修改，不影响调用者，因为这个值是调用者从他的本地变量表拷贝到操作数栈的；传递引用时，传的是堆对象的地址，当改了对象内容，调用者对象内容自然也变化了。之前的理解停留在“指针”，值传递，从未对底层发生的事情认识的如此清晰。</p><h3 id="bytecode解释例程">bytecode解释例程</h3><p>每一个字节码指令会有一段处理例程，完成当前指令的操作。并将字节码指令指针(r13寄存器)指向下一个需要解释执行字节码指令的地址，然后跳转到下个字节码指令的处理例程。</p><p>但实际实现，比这个稍稍复杂一点。每个字节码指令的需要完成的操作，不是完全都在当前指令的例程中的。有一部分会在下一个指令的例程中。这么设计，是为了寄存器传值优化，在解释执行时，可以减少内存的访问。下面介绍。</p><h4 id="tosstate">TosState</h4><p>操作数栈栈顶状态。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// TosState describes the top-of-stack state before and after the execution of</span>
<span class="c1">// a bytecode or method. The top-of-stack value may be cached in one or more CPU</span>
<span class="c1">// registers. The TosState corresponds to the 'machine represention' of this cached</span>
<span class="c1">// value. There's 4 states corresponding to the JAVA types int, long, float &amp; double</span>
<span class="c1">// as well as a 5th state in case the top-of-stack value is actually on the top</span>
<span class="c1">// of stack (in memory) and thus not cached. The atos state corresponds to the itos</span>
<span class="c1">// state when it comes to machine representation but is used separately for (oop)</span>
<span class="c1">// type specific operations (e.g. verification code).</span>

<span class="k">enum</span> <span class="n">TosState</span> <span class="p">{</span>         <span class="c1">// describes the tos cache contents</span>
  <span class="n">btos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>             <span class="c1">// byte, bool tos cached</span>
  <span class="n">ctos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>             <span class="c1">// char tos cached</span>
  <span class="n">stos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>             <span class="c1">// short tos cached</span>
  <span class="n">itos</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>             <span class="c1">// int tos cached</span>
  <span class="n">ltos</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>             <span class="c1">// long tos cached</span>
  <span class="n">ftos</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>             <span class="c1">// float tos cached</span>
  <span class="n">dtos</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>             <span class="c1">// double tos cached</span>
  <span class="n">atos</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>             <span class="c1">// object cached</span>
  <span class="n">vtos</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>             <span class="c1">// tos not cached</span>
  <span class="n">number_of_states</span><span class="p">,</span>
  <span class="n">ilgl</span>                  <span class="c1">// illegal state: should not occur</span>
<span class="p">};</span>
</code></pre></div></div><p>每个字节码指令解释例程生成时，会指定好，这个指令执行前需要依赖的栈顶状态in_tos,以及执行完后栈顶的状态out_tos。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//                                    interpr. templates</span>
  <span class="c1">// Java spec bytecodes                ubcp|disp|clvm|iswd  in    out   generator             argument</span>
  <span class="n">def</span><span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">_nop</span>                 <span class="p">,</span> <span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="p">,</span> <span class="n">vtos</span><span class="p">,</span> <span class="n">vtos</span><span class="p">,</span> <span class="n">nop</span>                 <span class="p">,</span>  <span class="n">_</span>           <span class="p">);</span>
  <span class="n">def</span><span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">_aconst_null</span>         <span class="p">,</span> <span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="p">,</span> <span class="n">vtos</span><span class="p">,</span> <span class="n">atos</span><span class="p">,</span> <span class="n">aconst_null</span>         <span class="p">,</span>  <span class="n">_</span>           <span class="p">);</span>
  <span class="n">def</span><span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">_iconst_m1</span>           <span class="p">,</span> <span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="p">,</span> <span class="n">vtos</span><span class="p">,</span> <span class="n">itos</span><span class="p">,</span> <span class="n">iconst</span>              <span class="p">,</span> <span class="o">-</span><span class="mi">1</span>           <span class="p">);</span>
  <span class="n">def</span><span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">_iconst_0</span>            <span class="p">,</span> <span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="p">,</span> <span class="n">vtos</span><span class="p">,</span> <span class="n">itos</span><span class="p">,</span> <span class="n">iconst</span>              <span class="p">,</span>  <span class="mi">0</span>           <span class="p">);</span>
  <span class="n">def</span><span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">_iconst_1</span>            <span class="p">,</span> <span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="p">,</span> <span class="n">vtos</span><span class="p">,</span> <span class="n">itos</span><span class="p">,</span> <span class="n">iconst</span>              <span class="p">,</span>  <span class="mi">1</span>           <span class="p">);</span>
  <span class="n">def</span><span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">_iconst_2</span>            <span class="p">,</span> <span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="p">,</span> <span class="n">vtos</span><span class="p">,</span> <span class="n">itos</span><span class="p">,</span> <span class="n">iconst</span>              <span class="p">,</span>  <span class="mi">2</span>           <span class="p">);</span>
  <span class="n">def</span><span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">_iconst_3</span>            <span class="p">,</span> <span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="o">|</span><span class="n">____</span><span class="p">,</span> <span class="n">vtos</span><span class="p">,</span> <span class="n">itos</span><span class="p">,</span> <span class="n">iconst</span>              <span class="p">,</span>  <span class="mi">3</span>           <span class="p">);</span>
  <span class="c1">// ......</span>
</code></pre></div></div><h4 id="dispatchtable">DispatchTable</h4><p>[栈顶状态，字节码指令] –&gt; 指令解释例程地址</p><p>看看定义：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DispatchTable</span> <span class="n">VALUE_OBJ_CLASS_SPEC</span> <span class="p">{</span>
  <span class="n">address</span> <span class="n">_table</span><span class="p">[</span><span class="n">number_of_states</span><span class="p">][</span><span class="n">length</span><span class="p">];</span> <span class="c1">// 第一维度为TosState，第二维度为字节码的值，对应一个字节码例程入口地址</span>
<span class="p">}</span> 
</code></pre></div></div><p>每个字节码指令例程在准备跳转到下一次的指令例程时，会根据当前的操作数栈栈顶状态，以及下一个指令的值，根据_table 选择jmp的地址。</p><p>下面以一个简单的iconst_1指令为例，说明常量 1 是如何压入到操作数栈中的。</p><p>JVM启动时，打上参数 -XX:+PrintInterpreter, 可以打印每个例程的入口地址，并反编译地址上的指令，反编译成对应平台的汇编。iconst_1反编译后如下：</p><pre><code class="language-x86asm">iconst_1  4 iconst_1  [0x00007fd7e102c4c0, 0x00007fd7e102c520]  96 bytes

Argument 0 is unknown.RIP: 0x7fd7e102c4c0 Code size: 0x00000060
  0x00007fd7e102c4c0: push    %rax
  0x00007fd7e102c4c1: jmpq    0x7fd7e102c4f0
  0x00007fd7e102c4c6: sub     $0x8,%rsp
  0x00007fd7e102c4ca: vmovss  %xmm0,(%rsp)
  0x00007fd7e102c4cf: jmpq    0x7fd7e102c4f0
  0x00007fd7e102c4d4: sub     $0x10,%rsp
  0x00007fd7e102c4d8: vmovsd  %xmm0,(%rsp)
  0x00007fd7e102c4dd: jmpq    0x7fd7e102c4f0
  0x00007fd7e102c4e2: sub     $0x10,%rsp
  0x00007fd7e102c4e6: mov     %rax,(%rsp)
  0x00007fd7e102c4ea: jmpq    0x7fd7e102c4f0
  0x00007fd7e102c4ef: push    %rax             # 这一行及以上，都是处理上一个指令的操作数栈内容。
  0x00007fd7e102c4f0: mov     $0x1,%eax        # 这一行开始，是处理iconst_1指令的。 把 1 放入eax寄存器。
  0x00007fd7e102c4f5: movzbl  0x1(%r13),%ebx   # 这一行开始，跳到下个指令例程。下一个指令的值存入ebx寄存器。
  0x00007fd7e102c4fa: incq    %r13             # r13寄存器指向下一个地址
  0x00007fd7e102c4fd: movabs  $0x7fd7f7500ca0,%r10  # _table[tosState] 基址
  0x00007fd7e102c507: jmpq    *(%r10,%rbx,8)        # 跳到 _table[tosState][bytecode] 的例程地址，执行下一个指令
  0x00007fd7e102c50b: nop
  0x00007fd7e102c50c: nop
</code></pre><p>注意上面rbx寄存器是64位，ebx是rbx的低32位。</p><p>开始可能会困惑，iconst_1的例程，只有把1放入eax寄存器，那么压操作数栈的操作在哪？</p><p>在下一个指令的例程。下面举2个例子来解释这个问题。</p><h5 id="寄存器传参">寄存器传参</h5><p>如果iconst_1指令，后面紧跟着 ineg 栈顶数值取反指令，那么会发生什么。</p><p>ineg 指令生成的汇编例程：</p><pre><code class="language-x86asm">ineg  116 ineg  [0x00007fd7e10304c0, 0x00007fd7e10304e0]  32 bytes

Argument 0 is unknown.RIP: 0x7fd7e10304c0 Code size: 0x00000020
  0x00007fd7e10304c0: mov     (%rsp),%eax   # vtos 入口地址
  0x00007fd7e10304c3: add     $0x8,%rsp     
  0x00007fd7e10304c7: neg     %eax          # itos 入口地址
  0x00007fd7e10304c9: movzbl  0x1(%r13),%ebx
  0x00007fd7e10304ce: incq    %r13
  0x00007fd7e10304d1: movabs  $0x7fd7f7500ca0,%r10
  0x00007fd7e10304db: jmpq    *(%r10,%rbx,8)
  0x00007fd7e10304df: nop
</code></pre><p>iconst_1 指令执行完，栈顶状态变为itos，所以在跳转到ineg例程时，会跳转到0x00007fd7e10304c7这个地址执行。</p><p>直接 neg %eax，对寄存器数值取反。所以从上一条iconst_1指令，到ineg完成取反，1这个值是通过CPU中的寄存器传递的，没有经过内存的操作，结果还存在于eax寄存器中，是否有必要入栈（还是字节寄存器传给下一条指令解释例程），取决于下一条指令依赖的栈顶状态in_tos。</p><p>正常未优化流程是， 1入操作数栈，下一条指令，再从栈顶弹出，拿到这个数值1。 通过这种栈顶缓存的设计，1 这个数就直接通过寄存器过去了，没有走内存，性能大大提升。</p><p>(延伸一下，还是ineg指令例程，如果是vtos入口进来的，会发生什么呢？</p><p>比如，4条指令： iconst_0, iconst_1, pop, ineg. 其中，ineg上一条指令pop的结束状态是vtos，所以走vtos入口0x00007fd7e10304c0，mov (%rsp), %eax ， 把rsp指向的地址的值传入eax，即操作数栈栈顶元素拷贝到eax寄存器。 然后rsp寄存器内容加8，因为栈顶是地址低位，所以+8相当于是弹出栈顶元素了。然后紧接着执行 neg %eax取反。 所以vtos进来的，经过了内存，拿到了iconst_0压入的常量0，此处必须经过内存，就走从内存中取值。)</p><h5 id="操作数栈传参">操作数栈传参</h5><p>还是上面的iconst_1，如果下一条又遇到iconst_1 呢。那么第二个iconst_1的入口地址是 0x00007fd7e102c4ef。</p><p>会先push %rax， 把rax寄存器内容压栈，再执行后面的iconst_1。 由于iconst_1不依赖栈顶的数，所以上一条的iconst_1在这里才被压入栈中。</p><p>（ 这里说明一下，栈帧创建后，操作数栈在栈帧的最下面（地址低位），rsp寄存器指向栈的最下面（栈顶），所以push指令压入的数就是在操作数栈中，所以压栈用的push指令。弹出栈元素，则将rsp+8即可（往地址高位移）。</p><p>所以，我理解操作数栈不像本地变量表，事先划好大小，操作数栈大小是不断变化的，因此当前方法栈帧的大小也会随解释执行而变化，调用下一个方法，下一个方法的栈帧起始位置也不确定。 ）</p><p><strong>所以一个数是否压栈，会取决于后面的指令类型，如果当前指令要往栈顶放的数恰好下一条指令要用到，那么直接寄存器传过去，就不用入栈退栈的操作了。</strong></p><p><strong>精妙！！!</strong></p><h4 id="例程生成器">例程生成器</h4><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">TemplateInterpreterGenerator</span><span class="o">::</span><span class="n">set_entry_points</span><span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">Code</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CodeletMark</span> <span class="n">cm</span><span class="p">(</span><span class="n">_masm</span><span class="p">,</span> <span class="n">Bytecodes</span><span class="o">::</span><span class="n">name</span><span class="p">(</span><span class="n">code</span><span class="p">),</span> <span class="n">code</span><span class="p">);</span>
  <span class="c1">// initialize entry points</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">_unimplemented_bytecode</span>    <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"should have been generated before"</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">_illegal_bytecode_sequence</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"should have been generated before"</span><span class="p">);</span>
  <span class="n">address</span> <span class="n">bep</span> <span class="o">=</span> <span class="n">_illegal_bytecode_sequence</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">cep</span> <span class="o">=</span> <span class="n">_illegal_bytecode_sequence</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">sep</span> <span class="o">=</span> <span class="n">_illegal_bytecode_sequence</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">aep</span> <span class="o">=</span> <span class="n">_illegal_bytecode_sequence</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">iep</span> <span class="o">=</span> <span class="n">_illegal_bytecode_sequence</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">lep</span> <span class="o">=</span> <span class="n">_illegal_bytecode_sequence</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">fep</span> <span class="o">=</span> <span class="n">_illegal_bytecode_sequence</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">_illegal_bytecode_sequence</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">vep</span> <span class="o">=</span> <span class="n">_unimplemented_bytecode</span><span class="p">;</span>
  <span class="n">address</span> <span class="n">wep</span> <span class="o">=</span> <span class="n">_unimplemented_bytecode</span><span class="p">;</span>
  <span class="c1">// code for short &amp; wide version of bytecode</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">is_defined</span><span class="p">(</span><span class="n">code</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Template</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">TemplateTable</span><span class="o">::</span><span class="n">template_for</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">is_valid</span><span class="p">(),</span> <span class="s">"just checking"</span><span class="p">);</span>
    <span class="n">set_short_entry_points</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">bep</span><span class="p">,</span> <span class="n">cep</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">aep</span><span class="p">,</span> <span class="n">iep</span><span class="p">,</span> <span class="n">lep</span><span class="p">,</span> <span class="n">fep</span><span class="p">,</span> <span class="n">dep</span><span class="p">,</span> <span class="n">vep</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Bytecodes</span><span class="o">::</span><span class="n">wide_is_defined</span><span class="p">(</span><span class="n">code</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Template</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">TemplateTable</span><span class="o">::</span><span class="n">template_for_wide</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">is_valid</span><span class="p">(),</span> <span class="s">"just checking"</span><span class="p">);</span>
    <span class="n">set_wide_entry_point</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">wep</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// set entry points</span>
  <span class="n">EntryPoint</span> <span class="n">entry</span><span class="p">(</span><span class="n">bep</span><span class="p">,</span> <span class="n">cep</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">aep</span><span class="p">,</span> <span class="n">iep</span><span class="p">,</span> <span class="n">lep</span><span class="p">,</span> <span class="n">fep</span><span class="p">,</span> <span class="n">dep</span><span class="p">,</span> <span class="n">vep</span><span class="p">);</span>
  <span class="n">Interpreter</span><span class="o">::</span><span class="n">_normal_table</span><span class="p">.</span><span class="n">set_entry</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
  <span class="n">Interpreter</span><span class="o">::</span><span class="n">_wentry_point</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">wep</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>bep, cep, …, dep 是8个地址。每个字节码解释例程会有多个入口地址，用来分情况处理上一字节码指令例程剩余未完成的栈操作。</p><p>上一个字节码指令解释执行完，会根据上一字节码指令的out_tos，来选择下一个字节码指令例程对应的state入口。</p><p>像上面的iconst_1的 in_tos 是 vtos，即不依赖栈顶元素。他的例程入口生成器是这样的：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Helper for vtos entry point generation</span>

<span class="kt">void</span> <span class="n">TemplateInterpreterGenerator</span><span class="o">::</span><span class="n">set_vtos_entry_points</span><span class="p">(</span><span class="n">Template</span><span class="o">*</span> <span class="n">t</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">bep</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">cep</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">sep</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">aep</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">iep</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">lep</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">fep</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">dep</span><span class="p">,</span>
                                                         <span class="n">address</span><span class="o">&amp;</span> <span class="n">vep</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">is_valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tos_in</span><span class="p">()</span> <span class="o">==</span> <span class="n">vtos</span><span class="p">,</span> <span class="s">"illegal template"</span><span class="p">);</span>
  <span class="n">Label</span> <span class="n">L</span><span class="p">;</span>
  <span class="n">aep</span> <span class="o">=</span> <span class="n">__</span> <span class="n">pc</span><span class="p">();</span>  <span class="n">__</span> <span class="n">push_ptr</span><span class="p">();</span>  <span class="n">__</span> <span class="n">jmp</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
  <span class="n">fep</span> <span class="o">=</span> <span class="n">__</span> <span class="n">pc</span><span class="p">();</span>  <span class="n">__</span> <span class="n">push_f</span><span class="p">();</span>    <span class="n">__</span> <span class="n">jmp</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
  <span class="n">dep</span> <span class="o">=</span> <span class="n">__</span> <span class="n">pc</span><span class="p">();</span>  <span class="n">__</span> <span class="n">push_d</span><span class="p">();</span>    <span class="n">__</span> <span class="n">jmp</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
  <span class="n">lep</span> <span class="o">=</span> <span class="n">__</span> <span class="n">pc</span><span class="p">();</span>  <span class="n">__</span> <span class="n">push_l</span><span class="p">();</span>    <span class="n">__</span> <span class="n">jmp</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
  <span class="n">bep</span> <span class="o">=</span> <span class="n">cep</span> <span class="o">=</span> <span class="n">sep</span> <span class="o">=</span>
  <span class="n">iep</span> <span class="o">=</span> <span class="n">__</span> <span class="n">pc</span><span class="p">();</span>  <span class="n">__</span> <span class="n">push_i</span><span class="p">();</span>
  <span class="n">vep</span> <span class="o">=</span> <span class="n">__</span> <span class="n">pc</span><span class="p">();</span>
  <span class="n">__</span> <span class="n">bind</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
  <span class="n">generate_and_dispatch</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>可以看出，和反编译出来的汇编指令，结构是完全一致的。</p><p>我上面对字节码指令解释例程不同state入口地址的分析，也是结合源码看出来的。</p><h2 id="字节码数据存储在哪">字节码数据存储在哪</h2><h3 id="instanceklass结构">InstanceKlass结构</h3><p>每一个Java的类，在JVM方法区，是一个Instancelass实例。</p><p>类加载时，会将.class转为JVM内部的数据结构。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">InstanceKlass</span><span class="o">:</span> <span class="k">public</span> <span class="n">Klass</span> <span class="p">{</span>
  <span class="n">Array</span><span class="o">&lt;</span><span class="n">Method</span><span class="o">*&gt;*</span> <span class="n">_methods</span><span class="p">;</span> <span class="c1">// 保存所有方法定义</span>
<span class="p">}</span>
</code></pre></div></div><p>Method中的ConstMethod，保存着字节码：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Method</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Metadata</span> <span class="p">{</span>
  <span class="n">ConstMethod</span><span class="o">*</span>      <span class="n">_constMethod</span><span class="p">;</span>                <span class="c1">// Method read-only data.</span>
  <span class="k">volatile</span> <span class="n">address</span>           <span class="n">_from_interpreted_entry</span><span class="p">;</span> <span class="c1">// Cache of _code ? _adapter-&gt;i2c_entry() : _i2i_entry</span>
<span class="p">}</span>
</code></pre></div></div><p>ConstMethod.hpp 节选：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// |------------------------------------------------------|</span>
<span class="c1">// | header                                               |</span>
<span class="c1">// | klass                                                |</span>
<span class="c1">// |------------------------------------------------------|</span>
<span class="c1">// | fingerprint 1                                        |</span>
<span class="c1">// | fingerprint 2                                        |</span>
<span class="c1">// | constants                      (oop)                 |</span>
<span class="c1">// | stackmap_data                  (oop)                 |</span>
<span class="c1">// | constMethod_size                                     |</span>
<span class="c1">// | interp_kind  | flags    | code_size                  |</span>
<span class="c1">// | name index              | signature index            |</span>
<span class="c1">// | method_idnum            | max_stack                  |</span>
<span class="c1">// | max_locals              | size_of_parameters         |</span>
<span class="c1">// |------------------------------------------------------|</span>
<span class="c1">// |                                                      |</span>
<span class="c1">// | byte codes                                           |</span>
<span class="c1">// |                                                      |</span>
</code></pre></div></div><p>我们的方法字节码指令即操作数就保存在oop/Method中的ConstMethod里面 的byte codes区域。</p><h3 id="方法链接">方法链接</h3><p>link。</p><p>是不是指的这个我再确定。</p><p>_from_interpreted_entry 会被赋值为这个方法类型对应的method_entry例程的入口地址。后面解释执行这个方法，只要callq这个地址就行了。</p><h2 id="字节码的顺序执行">字节码的顺序执行</h2><p>这里讲一下，每个指令结尾，以及method_entry结尾都要调用的dispatch函数，它负责找到字节码指令对应的指令解释例程。</p><h3 id="dispatch_next">dispatch_next</h3><p>注意，这也是一段例程Generator，它只会在hotspot启动时执行，在内存中应编码入指令，之后在解释执行时，执行的其实是这段程序硬编码到内存中的机器指令。</p><p>所以，下面注释的内容”XXX”，其实指的是 目的是”XXX”的汇编指令生成代码。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">InterpreterMacroAssembler</span><span class="o">::</span><span class="n">dispatch_next</span><span class="p">(</span><span class="n">TosState</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">step</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">load_unsigned_byte</span><span class="p">(</span><span class="n">rbx</span><span class="p">,</span> <span class="n">Address</span><span class="p">(</span><span class="n">r13</span><span class="p">,</span> <span class="n">step</span><span class="p">));</span> <span class="c1">// 将r13寄存器的地址加上step，得到的地址上的值，存入rbx寄存器，即下一个指令的值</span>
  <span class="n">increment</span><span class="p">(</span><span class="n">r13</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span> <span class="c1">//r13寄存器加step，下一个指令的内存地址</span>
  <span class="n">dispatch_base</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">Interpreter</span><span class="o">::</span><span class="n">dispatch_table</span><span class="p">(</span><span class="n">state</span><span class="p">));</span> <span class="c1">// 跳转到下一个字节码的执行</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="dispatch_base">dispatch_base</h3><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">InterpreterMacroAssembler</span><span class="o">::</span><span class="n">dispatch_base</span><span class="p">(</span><span class="n">TosState</span> <span class="n">state</span><span class="p">,</span>
                                              <span class="n">address</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span>
                                              <span class="kt">bool</span> <span class="n">verifyoop</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">verify_FPU</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">VerifyActivationFrameSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Label</span> <span class="n">L</span><span class="p">;</span>
    <span class="n">mov</span><span class="p">(</span><span class="n">rcx</span><span class="p">,</span> <span class="n">rbp</span><span class="p">);</span>
    <span class="n">subptr</span><span class="p">(</span><span class="n">rcx</span><span class="p">,</span> <span class="n">rsp</span><span class="p">);</span>
    <span class="kt">int32_t</span> <span class="n">min_frame_size</span> <span class="o">=</span>
      <span class="p">(</span><span class="n">frame</span><span class="o">::</span><span class="n">link_offset</span> <span class="o">-</span> <span class="n">frame</span><span class="o">::</span><span class="n">interpreter_frame_initial_sp_offset</span><span class="p">)</span> <span class="o">*</span>
      <span class="n">wordSize</span><span class="p">;</span>
    <span class="n">cmpptr</span><span class="p">(</span><span class="n">rcx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">min_frame_size</span><span class="p">);</span>
    <span class="n">jcc</span><span class="p">(</span><span class="n">Assembler</span><span class="o">::</span><span class="n">greaterEqual</span><span class="p">,</span> <span class="n">L</span><span class="p">);</span>
    <span class="n">stop</span><span class="p">(</span><span class="s">"broken stack frame"</span><span class="p">);</span>
    <span class="n">bind</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">verifyoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">verify_oop</span><span class="p">(</span><span class="n">rax</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
  <span class="p">}</span> <span class="c1">// 前面的操作，还不懂。</span>

  <span class="n">lea</span><span class="p">(</span><span class="n">rscratch1</span><span class="p">,</span> <span class="n">ExternalAddress</span><span class="p">((</span><span class="n">address</span><span class="p">)</span><span class="n">table</span><span class="p">));</span> <span class="c1">// 这个rscratch1是 table[tos_state]的地址</span>
  <span class="n">jmp</span><span class="p">(</span><span class="n">Address</span><span class="p">(</span><span class="n">rscratch1</span><span class="p">,</span> <span class="n">rbx</span><span class="p">,</span> <span class="n">Address</span><span class="o">::</span><span class="n">times_8</span><span class="p">));</span> <span class="c1">// 二维寻址，跳到table[tos_state][bytecode]去执行。</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="指令跳转">指令跳转</h3><p>上面介绍了，非跳转指令执行结束，是如何跳到下一个指令的。还有一些分支指令，是会主动跳转的。比如if_icmpeq，比较栈顶两个元素是否相等。跳转会跳转到指令后面两个字节表示的字节码指令地址上。（2^16字节码指令寻址空间）</p><p>最终也是通过修改r13寄存器，rbx寄存器，调用dispatch_base来完成最终跳转指令的生成。</p><h1 id="总结">总结</h1><p>开始，先观察学习Java程序编译产物 .class文件结构，将JVM当黑盒来理解内部解释字节码指令的机理。</p><p>而后，打开hotspot源码，寻找解释每个字节码指令的程序段，以及分析 包含本地变量表和操作数栈 的 栈帧 基本结构，分析 创建栈帧并jmp到第一个字节码指令例程的 method_entry 例程。</p><p>然后是，分析了下这几个例程的创建代码 以及 字节码在虚拟机中存储在哪。</p><p>最后，</p><p>新世界的大门已然开启。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://ykry35.github.io/blog.github.io" target="_blank">Chaoxin Zhou</a></li><li>本文链接：<a href="https://ykry35.github.io/blog.github.io/2021/09/01/how_does_the_java_program_run/" target="_blank">https://ykry35.github.io/blog.github.io/2021/09/01/how_does_the_java_program_run/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/09/01/how_does_the_java_program_run/', clientID: 'a3a0fbaad3e91f2e2342', clientSecret: 'f82d523505992a3aab199b818ecff081b65f1a60', repo: 'blog.github.io', owner: 'ykry35', admin: ['ykry35'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://ykry35.github.io/blog.github.io/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://ykry35.github.io/blog.github.io/assets/search_data.json?v=1672582836', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://ykry35.github.io/blog.github.io/assets/js/jquery.toc.js"></script></div></div><script type="text/javascript"> $(document).ready(function(){ $('.images_group').each(function(index, element) { new Viewer(element); }); }); </script></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Chaoxin Zhou">Chaoxin Zhou</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/YKRY35/" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://ykry35.github.io/blog.github.io/" title="首页" target="">首页</a></li><li> <a href="https://ykry35.github.io/blog.github.io/categories/" title="分类" target="">分类</a></li><li> <a href="https://ykry35.github.io/blog.github.io/wiki/" title="维基" target="">维基</a></li><li> <a href="https://ykry35.github.io/blog.github.io/links/" title="链接" target="">链接</a></li><li> <a href="https://ykry35.github.io/blog.github.io/about/" title="关于" target="">关于</a></li><li><a href="https://ykry35.github.io/blog.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://ykry35.github.io/blog.github.io/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
