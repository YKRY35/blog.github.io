<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>jacoco改造之探针外置 &mdash; Zhou</title><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/collection.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/globals/common.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/posts/index.css"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/octicons/octicons/octicons.css"><link href="https://ykry35.github.io/blog.github.io/assets/vendor/viewerjs/viewer.min.css" rel="stylesheet"><link href="https://ykry35.github.io/blog.github.io/assets/css/globals/viewerjs.cust.css" rel="stylesheet"><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/css/code_theme/github.css"><link rel="canonical" href="https://ykry35.github.io/blog.github.io/p2/testerhome/jacoco_outer_probes/"><link rel="alternate" type="application/atom+xml" title="Zhou" href="https://ykry35.github.io/blog.github.io/feed.xml"><link rel="shortcut icon" href="https://ykry35.github.io/blog.github.io/favicon.ico"><meta property="og:title" content="jacoco改造之探针外置"><meta name="keywords" content="JVM, hotspot, Java"><meta name="og:keywords" content="JVM, hotspot, Java"><meta name="description" content="a"><meta name="og:description" content="a"><meta property="og:url" content="https://ykry35.github.io/blog.github.io/p2/testerhome/jacoco_outer_probes/"><meta property="og:site_name" content="Zhou"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /> <script src="https://ykry35.github.io/blog.github.io/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/js/jquery-ui.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/js/main.js"></script> <script src="https://ykry35.github.io/blog.github.io/assets/vendor/viewerjs/viewer.min.js"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?21948165144e39ea102cb9ab226cef96"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://ykry35.github.io/blog.github.io/" title="Zhou"><span class="octicon octicon-mark-github"></span> Zhou</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://ykry35.github.io/blog.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://ykry35.github.io/blog.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://ykry35.github.io/blog.github.io/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://ykry35.github.io/blog.github.io/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://ykry35.github.io/blog.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="jacoco改造之探针外置"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">jacoco改造之探针外置</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://ykry35.github.io/blog.github.io/categories/#JVM" title="JVM">JVM</a> </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>下文基于 JDK8 和 jacoco 0.8.7</p><h1 id="jacoco原理简述">jacoco原理简述</h1><p>Jacoco是一个开源的覆盖率工具,针对java语言。它可以统计Java运行的类方法每个指令的代码覆盖情况。</p><p>jacoco的使用方式可以是动态插桩(javaagent)，也可以是静态插桩(静态class文件注入)。这里讨论以动态插桩为例。</p><p>”插桩“：对原有程序进行代码注入。</p><p>由于我们要收集覆盖率，因此需要向被收集程序插桩，注入一些监控代码，来采集被收集程序代码覆盖情况。</p><h2 id="代码插桩时机">代码插桩时机</h2><p>那么代码插桩发生在什么时候呢？</p><p>我们知道，一般情况下，我们执行Java程序，都是加载的本地class文件。因此类加载就是： 从JVM外部的流(例如磁盘文件)中读取class数据到JVM内部解析后作为“类”。这个类加载是由JVM的类加载子系统完成的。</p><p><img src="https://ykry35.github.io/blog.github.io/assets/images/jvm/javaagent_loadclass.png" alt="" /></p><p>类加载子系统获得一个class的流以后，会将其解析校验，合法后会生成JVM内部”类“结构Klass，存储在元空间(JDK7以前的方法区)中。</p><p>那么代码插桩，就发生于类加载子系统的前置位置（图中的左侧，箭头1的终点）。类加载子系统刚拿到原始流，会提供给我们插桩程序，我们插桩程序返回插桩以后的字节码文件流给类加载子系统，类加载子系统按照修改过后的字节码流来解析。所以最后元空间内的”类“表示Klass，会包含我们注入的代码。</p><p><img src="https://ykry35.github.io/blog.github.io/assets/images/jvm/javaagent_loadclass_instrument.png" alt="" /></p><p>如上图，我们的插桩程序，其实在ClassFileLoadHook回调中，我们可以拿到类加载原始的A.class内容，并返回修改后的A.class内容。修改后的字节码注入了我们的采集程序。</p><p>下面可以看到类加载解析类前，会发送jvmti事件，允许替换字节码流。</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">instanceKlassHandle</span> <span class="n">ClassFileParser</span><span class="o">::</span><span class="n">parseClassFile</span><span class="p">(</span><span class="n">Symbol</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span>
                                                    <span class="n">ClassLoaderData</span><span class="o">*</span> <span class="n">loader_data</span><span class="p">,</span>
                                                    <span class="n">Handle</span> <span class="n">protection_domain</span><span class="p">,</span>
                                                    <span class="n">KlassHandle</span> <span class="n">host_klass</span><span class="p">,</span>
                                                    <span class="n">GrowableArray</span><span class="o">&lt;</span><span class="n">Handle</span><span class="o">&gt;*</span> <span class="n">cp_patches</span><span class="p">,</span>
                                                    <span class="n">TempNewSymbol</span><span class="o">&amp;</span> <span class="n">parsed_name</span><span class="p">,</span>
                                                    <span class="n">bool</span> <span class="n">verify</span><span class="p">,</span>
                                                    <span class="n">TRAPS</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// 省略了一段</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">JvmtiExport</span><span class="o">::</span><span class="n">should_post_class_file_load_hook</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Get the cached class file bytes (if any) from the class that</span>
    <span class="c1">// is being redefined or retransformed. We use jvmti_thread_state()</span>
    <span class="c1">// instead of JvmtiThreadState::state_for(jt) so we don't allocate</span>
    <span class="c1">// a JvmtiThreadState any earlier than necessary. This will help</span>
    <span class="c1">// avoid the bug described by 7126851.</span>
    <span class="n">JvmtiThreadState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">jt</span><span class="o">-&gt;</span><span class="n">jvmti_thread_state</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">KlassHandle</span> <span class="o">*</span><span class="n">h_class_being_redefined</span> <span class="o">=</span>
                     <span class="n">state</span><span class="o">-&gt;</span><span class="n">get_class_being_redefined</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">h_class_being_redefined</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">instanceKlassHandle</span> <span class="n">ikh_class_being_redefined</span> <span class="o">=</span>
          <span class="n">instanceKlassHandle</span><span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">h_class_being_redefined</span><span class="p">)());</span>
        <span class="n">cached_class_file</span> <span class="o">=</span> <span class="n">ikh_class_being_redefined</span><span class="o">-&gt;</span><span class="n">get_cached_class_file</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">cfs</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">end_ptr</span> <span class="o">=</span> <span class="n">cfs</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">cfs</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">();</span>

    <span class="n">JvmtiExport</span><span class="o">::</span><span class="n">post_class_file_load_hook</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">class_loader</span><span class="p">(),</span> <span class="n">protection_domain</span><span class="p">,</span>
                                           <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_class_file</span><span class="p">);</span> <span class="c1">// JVMTI事件</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="n">cfs</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// JVMTI agent has modified class file data.</span>
      <span class="c1">// Set new class file stream using JVMTI agent modified</span>
      <span class="c1">// class file data.</span>
      <span class="n">cfs</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ClassFileStream</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">end_ptr</span> <span class="o">-</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">cfs</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">());</span>
      <span class="n">set_stream</span><span class="p">(</span><span class="n">cfs</span><span class="p">);</span> <span class="c1">// 这里替换掉原来要解析的流</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 省略</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="关于instrument模块">关于instrument模块</h2><p>JVM本身在实现时，提供了很多回调接口，基于这些回调接口(JVMTI: JVM Tool Interface)，可以开发出丰富的功能。</p><p>例如Java的调试器模块jdwp.so、 javaagent的实现模块instrument.so，他们不是hotspot JVM的一部分，他们是Oracle JDK的一部分。</p><p>下面简述流程。</p><p><img src="https://ykry35.github.io/blog.github.io/assets/images/jvm/javaagent_instrument_process.png" alt="" /></p><ol><li><p>JVM启动时，解析-javaagent参数或agentlib:instrument参数(两者等价)，发现了需要instrument模块.</p></li><li><p>读取动态链接库instrument.so，找到里头的Agent_OnLoad回调函数地址，并调用。</p></li><li><p>instrument.so中的Agent_OnLoad注册VMInit事件</p></li><li><p>虚拟机开始初始化。</p></li><li><p>初始化完成，发送JVMTI的JVMInit事件给注册者。</p></li><li><p>instrument.so刚才注册JVMInit中，注册ClassFileLoadHook事件，请求拦截所有后续类加载事件。</p></li><li><p>虚拟机开始寻找staic void main函数，并执行。 这其间必然涉及大量的类加载，类加载拿到流时，会触发ClassFIleLoadHook事件，instrument.so中注册的ClassFileLoadHook事件，最终会转发到Java层的Transformer设计，能够达到操作字节码的效果。</p></li></ol><h2 id="字节码插桩策略">字节码插桩策略</h2><p>前面讲了为什么能够操作字节码。接下来讲怎么修改字节码来达到监控的效果。</p><p>我想监控这个类A的a方法的行覆盖情况，那么怎么做呢。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
	<span class="kt">int</span> <span class="nf">a</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
		<span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
			<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
		<span class="o">}</span><span class="k">else</span><span class="o">{</span>
			<span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>只要注入一些字段和字节码指令就可以达到监控。注入后的类长这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">$probes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

	<span class="kt">int</span> <span class="nf">a</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
		<span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
			<span class="n">$probes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
		<span class="o">}</span><span class="k">else</span><span class="o">{</span>
			<span class="n">$probes</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
			<span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>方案很直观，在所有的“分支”上埋上一个探针”probe”即可。</p><p>$probes[0]记录(x&gt;0)分支内代码是否被执行,$probes[1]记录(x&lt;=0)分支内代码是否被执行。</p><p>最后收集A.$probes即可分析出类A的覆盖情况。</p><p><em>NOTE</em>: 实际的插桩是面向指令级别的程序流的，因此实际插的位置可能和java语言层（上面写在java语言中是为了方便说明）的有出入。最终保证，每一个探针可以确定前面N个指令的执行情况；可能还会涉及”比较“指令的反转。还有$boolean的初始化时机不是类加载，而是第一次访问探针(上面是为了说明，直接new)。这里是为了方便介绍。</p><h1 id="探针外置">探针外置</h1><h2 id="目的">目的</h2><p>往类A中增加的字段boolean[] $probes，某些情况下可能会影响应用自身原本的行为。</p><p>就比如，某些序列化实现，不管boolean $probes的修饰SYNTHETIC，将框架注入的“探针”字段一并序列化，造成影响应用(反序列化那端没这个字段)。</p><p>所以想把每个类中都会注入的boolean[] $probes给拿到外面去。不影响每个类的field。</p><h2 id="方案">方案</h2><p>步骤：</p><ol><li><p>为每个类A构造一个类A$X，专门存储类A的探针数据。</p></li><li><p>A$X挂在类A的defining loader上。</p></li><li><p>类A对探针的访问都通过A$X.$probes来完成。</p></li></ol><p>最后像这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span><span class="n">$X</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">$probes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">$probes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

	<span class="kt">int</span> <span class="nf">a</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
		<span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
			<span class="no">A</span><span class="n">$X</span><span class="o">.</span><span class="n">$probes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
		<span class="o">}</span><span class="k">else</span><span class="o">{</span>
			<span class="no">A</span><span class="n">$X</span><span class="o">.</span><span class="n">$probes</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
			<span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>最后统计A$X.$probes即可收集类A的覆盖率情况了。</p><p>这里面涉及一些技术上的细节问题，在下面的”可行原理“中叙述。</p><h1 id="可行原理">可行原理</h1><h2 id="前置概念">前置概念</h2><p>Issue: 什么是defining loader？</p><p>简述defining loader和initiating loader的区别。</p><p>写一个简单的类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">extends</span> <span class="nc">Object</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>

	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>运行。最后是这样的：</p><p><img src="https://ykry35.github.io/blog.github.io/assets/images/p2/testerhome/classloader_example.png" alt="" /></p><p>因为存在委派，所以最开始触发加载器loadClass的Loader就是那个类的initiating loader。委派后，最终defineClass的那个Loader就是那个类的defining loader。</p><p>上面这个例子中，AppLoader解析类C的过程中，会解析其父类Object，如果没加载过(没做为initiating loader)，那么会触发AppLoader的loadClass尝试对Object进行加载，最终委派给BootLoader，拿到Class模型后，AppLoader会被记录为C的initiating loader，下次不会再触发AppLoader对Object的加载行为(loadClass).</p><p>这个详细原理，在虚拟机规范8的5.3章有详细说明。</p><h2 id="为什么a能访问到ax">为什么A能访问到A$X</h2><h3 id="简单地说">简单地说</h3><p>我们将类A$X放在类A的defining loader上。</p><p>看虚拟机规范5.3这段话：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If N denotes a nonarray class or an interface, one of the two following methodsis used to load and thereby create C:
–  If D was defined by the bootstrap class loader, then the bootstrap class loaderinitiates loading of C (§5.3.1).
–  If D was defined by a user-defined class loader, then that same user-definedclass loader initiates loading of C (§5.3.2)
</code></pre></div></div><p>假设A的definig loader是L。</p><p>最后，当类A访问A$X的时候，根据第二条规则，类A的definig loader L会作为A$X的initiating loader。</p><p>而我们已经提前把A$X挂在L上了。L发现已经加载过A$X，不会触发L在java层的loadClass方法（因为一旦触发到java层，那它是一定加载不到的，程序就会有问题）。L会直接把A$X的类模型给返还。</p><p>所以A$X挂在L是避开了触发类加载。</p><h3 id="往细了说">往细了说</h3><p>A访问A$X的字段，对于A来说，”A$X”只是字符串常量，存在于A的常量池中。</p><p>当A第一次用到A$X时，发现常量池中是符号引用，是个字串”A$X”，说明这个类没有被当前类解析，要由符号引用转地址引用。</p><p>这时A的defining loader会负责解析”A$X”这个类，这时发现加载过了，那么直接返回类模型InstanceKlass*，然后填入到A的常量池中。</p><p>下次A访问A$X时，由于常量池是A$X的类模型地址，因此不会触发到加载器的行为。</p><p>hotspot源码可以看出这个过程：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Klass</span><span class="o">*</span> <span class="n">ConstantPool</span><span class="o">::</span><span class="n">klass_at_impl</span><span class="p">(</span><span class="n">constantPoolHandle</span> <span class="n">this_oop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="n">TRAPS</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Symbol</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">Handle</span>       <span class="n">loader</span><span class="p">;</span>
  <span class="p">{</span>  <span class="n">MonitorLockerEx</span> <span class="n">ml</span><span class="p">(</span><span class="n">this_oop</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">this_oop</span><span class="o">-&gt;</span><span class="n">tag_at</span><span class="p">(</span><span class="n">which</span><span class="p">).</span><span class="n">is_unresolved_klass</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">this_oop</span><span class="o">-&gt;</span><span class="n">tag_at</span><span class="p">(</span><span class="n">which</span><span class="p">).</span><span class="n">is_unresolved_klass_in_error</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">in_error</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">do_resolve</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">name</span>   <span class="o">=</span> <span class="n">this_oop</span><span class="o">-&gt;</span><span class="n">unresolved_klass_at</span><span class="p">(</span><span class="n">which</span><span class="p">);</span> <span class="c1">// 拿到目标类名</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="n">Handle</span><span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">this_oop</span><span class="o">-&gt;</span><span class="n">pool_holder</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">class_loader</span><span class="p">());</span> <span class="c1">//拿到当前类加载器</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="c1">// unlocking constantPool</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">do_resolve</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this_oop must be unlocked during resolve_or_fail</span>
    <span class="n">oop</span> <span class="n">protection_domain</span> <span class="o">=</span> <span class="n">this_oop</span><span class="o">-&gt;</span><span class="n">pool_holder</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protection_domain</span><span class="p">();</span>
    <span class="n">Handle</span> <span class="n">h_prot</span> <span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">protection_domain</span><span class="p">);</span>
    <span class="c1">// 执行加载。 用当前类加载器尝试去加载目标类</span>
    <span class="n">Klass</span><span class="o">*</span> <span class="n">k_oop</span> <span class="o">=</span> <span class="n">SystemDictionary</span><span class="o">::</span><span class="n">resolve_or_fail</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">h_prot</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">THREAD</span><span class="p">);</span>
    <span class="n">KlassHandle</span> <span class="n">k</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HAS_PENDING_EXCEPTION</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">k</span> <span class="o">=</span> <span class="n">KlassHandle</span><span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">k_oop</span><span class="p">);</span>
      <span class="c1">// preserve the resolved klass.</span>
      <span class="n">mirror_handle</span> <span class="o">=</span> <span class="n">Handle</span><span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">k_oop</span><span class="o">-&gt;</span><span class="n">java_mirror</span><span class="p">());</span>
      <span class="c1">// Do access check for klasses</span>
      <span class="n">verify_constant_pool_resolve</span><span class="p">(</span><span class="n">this_oop</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">THREAD</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>类加载在虚拟机里较为复杂，后续另开篇幅介绍。</p><h2 id="如何把ax放在l上">如何把A$X放在L上</h2><p><strong><em>Issue: 如何把凭空构造的类A$X挂到A的defining loader L上?</em></strong></p><p>所有的类加载器必继承ClassLoader。</p><p>反射调用其 defineClass(),传入A$X的字节码。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ClassLoader</span><span class="o">{</span>
	<span class="kd">protected</span> <span class="kd">final</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">defineClass</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span>
	        <span class="kd">throws</span> <span class="nc">ClassFormatError</span>
	    <span class="o">{</span>
	        <span class="k">return</span> <span class="nf">defineClass</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">off</span><span class="o">,</span> <span class="n">len</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
	    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong><em>Issue: 怎么凭空构造A$X的字节码byte[] ?</em></strong></p><p>这里基于ASM，生成了一个类的字节码表示byte[]。</p><p><strong><em>Issue: defineClass调用后？</em></strong></p><p>Java层最后会调用到Native方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">native</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">defineClass1</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">,</span>
                                         <span class="nc">ProtectionDomain</span> <span class="n">pd</span><span class="o">,</span> <span class="nc">String</span> <span class="n">source</span><span class="o">);</span>
</code></pre></div></div><p>JNI进来了：</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">JNIEXPORT</span> <span class="n">jclass</span> <span class="n">JNICALL</span>
<span class="nf">Java_java_lang_ClassLoader_defineClass1</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
                                        <span class="n">jobject</span> <span class="n">loader</span><span class="p">,</span>
                                        <span class="n">jstring</span> <span class="n">name</span><span class="p">,</span>
                                        <span class="n">jbyteArray</span> <span class="n">data</span><span class="p">,</span>
                                        <span class="n">jint</span> <span class="n">offset</span><span class="p">,</span>
                                        <span class="n">jint</span> <span class="n">length</span><span class="p">,</span>
                                        <span class="n">jobject</span> <span class="n">pd</span><span class="p">,</span>
                                        <span class="n">jstring</span> <span class="n">source</span><span class="p">);</span>
</code></pre></div></div><p>然后走到这:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">jclass</span> <span class="nf">jvm_define_class_common</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                                      <span class="n">jobject</span> <span class="n">loader</span><span class="p">,</span> <span class="k">const</span> <span class="n">jbyte</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                                      <span class="n">jsize</span> <span class="n">len</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">pd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
                                      <span class="n">jboolean</span> <span class="n">verify</span><span class="p">,</span> <span class="n">TRAPS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 省略一段</span>

  <span class="n">Handle</span> <span class="n">protection_domain</span> <span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">JNIHandles</span><span class="o">::</span><span class="n">resolve</span><span class="p">(</span><span class="n">pd</span><span class="p">));</span>
  <span class="n">Klass</span><span class="o">*</span> <span class="n">k</span> <span class="o">=</span> <span class="n">SystemDictionary</span><span class="o">::</span><span class="n">resolve_from_stream</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">class_loader</span><span class="p">,</span>
                                                     <span class="n">protection_domain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span>
                                                     <span class="n">verify</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                                     <span class="n">CHECK_NULL</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">TraceClassResolution</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">trace_class_resolution</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">jclass</span><span class="p">)</span> <span class="n">JNIHandles</span><span class="o">::</span><span class="n">make_local</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">java_mirror</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div><p>jvm_define_class_common会解析流，得到Klass模型，然后获得Java层的反射模型 Class作为结果返回去。</p><p>defineClass进入JNI后，JVM会完成字节码解析，并创建类，将类挂在目标加载器，同时返回结果。</p><h1 id="性能影响">性能影响</h1><h2 id="字段访问性能">字段访问性能</h2><p>探针外置，让从访问自己类的静态变量，到访问其他类的静态变量，这里会造成性能差异吗？</p><p>性能一致的。都会将目标Field地址信息填在自己的CpCache中。</p><p>关键字：ConstantPoolCache， 指令重写rewrite</p><h2 id="类变多的影响">类变多的影响</h2><p>对于加载器寻找已加载类的性能，没什么太大影响。 类和加载器做哈希后存储在开散列中，这个开散列是会动态调整的(rehash)，保证搜索性能。</p><p>关键字: SystemDictionary</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://ykry35.github.io/blog.github.io" target="_blank">Chaoxin Zhou</a></li><li>本文链接：<a href="https://ykry35.github.io/blog.github.io/p2/testerhome/jacoco_outer_probes/" target="_blank">https://ykry35.github.io/blog.github.io/p2/testerhome/jacoco_outer_probes/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://ykry35.github.io/blog.github.io/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/p2/testerhome/jacoco_outer_probes/', clientID: 'a3a0fbaad3e91f2e2342', clientSecret: 'f82d523505992a3aab199b818ecff081b65f1a60', repo: 'blog.github.io', owner: 'ykry35', admin: ['ykry35'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://ykry35.github.io/blog.github.io/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://ykry35.github.io/blog.github.io/assets/search_data.json?v=1673319207', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://ykry35.github.io/blog.github.io/assets/js/jquery.toc.js"></script></div></div><script type="text/javascript"> $(document).ready(function(){ const jekyllConfigId = '#jekyllconfig'; const imageGroupClass = '.images_group'; $(jekyllConfigId).hide(); var configStr = $(jekyllConfigId).text().trim(); const jekyllConfig = JSON.parse(configStr); console.log("jekyllConfig", jekyllConfig); $(imageGroupClass + ' li').css('width', jekyllConfig['viewerjs']['img_width']); $(imageGroupClass).each(function(index, element) { new Viewer(element); }); }); </script></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2021 <span title="Chaoxin Zhou">Chaoxin Zhou</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/YKRY35/" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://ykry35.github.io/blog.github.io/" title="首页" target="">首页</a></li><li> <a href="https://ykry35.github.io/blog.github.io/categories/" title="分类" target="">分类</a></li><li> <a href="https://ykry35.github.io/blog.github.io/wiki/" title="维基" target="">维基</a></li><li> <a href="https://ykry35.github.io/blog.github.io/links/" title="链接" target="">链接</a></li><li> <a href="https://ykry35.github.io/blog.github.io/about/" title="关于" target="">关于</a></li><li><a href="https://ykry35.github.io/blog.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://ykry35.github.io/blog.github.io/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
